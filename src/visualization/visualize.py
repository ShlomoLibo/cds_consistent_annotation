import copy
from itertools import groupby
from typing import List
import matplotlib.pyplot as plt
from .range_tools import Range, divide_set, union_sets
import datetime
from pathlib import Path
import random


def save_with_timestamp(name="figure"):
    # Generate a unique filename, to make sure a plot is not overridden
    random_num = str(random.randint(1, 10000))
    filename = f"{name}_{datetime.datetime.now().strftime('%H%M%S%f')}_{random_num}.png"
    project_dir = Path(__file__).resolve().parents[2]
    figures_dir = project_dir / Path("reports/figures")

    # Save the figure with the autogenerated filename
    plt.savefig(project_dir / figures_dir / filename)


class VisualizableRange(Range):
    """
    An interface to work with the visualization functions, represents ranges with start and end positions
    that we want to visualize.
    """
    color: str
    marker: str
    vertical_offset: float = 0.0
    label: str = None
    group: str = None  # all members of the same group are insured to have the same start position during visualization
    # (if align_sets is called). also responsible y-axis labeling


def align_sets(sets: List[List[VisualizableRange]]) -> List[List[VisualizableRange]]:
    """

    :param sets: list of sets, each set is represented as a collection of a start and end positions (ranges).
    :return: aligned sets, such that for each group of sets (group determined by Range.group attribute), starts from 0.
    """

    # group the ranges by the "group" attribute of VisualizedRange, in each group find the minimal start position
    # and align every group based on that start position
    grouped_sets = groupby(sorted(sets, key=lambda lst: lst[0].group), key=lambda lst: lst[0].group)
    new_sets = []
    for _, group in grouped_sets:
        group: List[List[VisualizableRange]] = list(group)
        start_pos = min([r for annotations in group for r in annotations], key=lambda r: r.start).start
        for annotations in group:
            new_annotations = []
            if not annotations:
                continue
            for annotation in annotations:
                aligned_annotation = copy.copy(annotation)
                aligned_annotation.start -= start_pos
                aligned_annotation.end -= start_pos
                new_annotations.append(aligned_annotation)
            new_sets.append(new_annotations)
    return new_sets


def visualize_blast_results(
        sets: List[List[VisualizableRange]],
        compare: List[List[VisualizableRange]] = None,
        separate_plots=False,
        compare_offset=0,
        figure_name="blast_results"
):
    """
  Visualizes the input sets and comparison using Matplotlib.
  Plots the data with breaking points on the x-axis.
  Parameters:
  sets: a list of sets of points, where each set is represented by a list of ExonAnnotation objects,
        and each object represents a range.
  """
    if compare is None:
        compare = list(list())

    # align blast results and comparison on the x-axis.
    new_compare = []
    for set_ in compare:
        new_set = []
        for annotation in set_:
            offset_annotation = copy.copy(annotation)
            offset_annotation.start = annotation.start - compare_offset
            offset_annotation.end = annotation.end - compare_offset
            new_set.append(offset_annotation)
        new_compare.append(new_set)
    visualize_sets(new_compare + sets, separate_plots=separate_plots, figure_name=figure_name)


def visualize_sets(
        sets: List[List[VisualizableRange]],
        separate_plots=False,
        distance=5000,
        margin=1000,
        figure_name="figure"
):
    """
    Plots a list of sets, each set is represented as a collection of a start and end positions (ranges).
    Visualizes the ranges in accordance with VisualizableRange attributes.
    When large gaps exist in the data, cuts the gap for better visualization (if separate_plots==False),
    if separate_plots==True, plots the regions between each large gap separately.
    :param sets: list of sets, each set is represented as a collection of a start and end positions (ranges).
    :param separate_plots: weather to plot regions between large gaps separately.
    :param distance: What qualifies as a large gap
    :param margin: a small buffer for each region (area between gap), should be smaller than distance
    :param figure_name: how to name the generated plot
    """

    # make breaking points between sets with large distance between each other result
    smaller_sets = divide_set(union_sets(sets), distance=distance)
    xlims = [(min(ranges, key=lambda x: x.start).start - margin, max(ranges, key=lambda x: x.end).end + margin) for
             ranges in
             smaller_sets]

    if separate_plots:
        def ax_generator(n):
            for i in range(n):
                yield plt.subplots(1, 1)[1]

        axs = ax_generator(len(xlims))
    else:
        fig, axs = plt.subplots(1, len(xlims), sharey=True)
        if len(xlims) == 1:
            axs = [axs]

    # iterate over the data and x-axis limits
    for i, (ax, xlim) in enumerate(zip(axs, xlims)):
        # plot the data on the subplot
        # plot the ranges in each set
        tick_positions = {}
        for j, s in enumerate(sets):
            for r in s:
                ax.plot([r.start, r.end], [j - r.vertical_offset, j - r.vertical_offset], "-", linewidth=10,
                        color=r.color, marker=r.marker, mfc="black", mec="black")
                if r.label:
                    tick_positions[j] = r.label

        # set the x-axis limits for the subplot
        ax.set_xlim(*xlim)
        if separate_plots:
            plt.yticks(*list(zip(*tick_positions.items())))
            save_with_timestamp(figure_name)

        else:
            ax.set_yticks([])

            # hide the spines between the subplots (doesn't work for some reason)
            if i > 0:
                ax.spines.left.set_visible(False)

            if i < len(xlims) - 1:
                ax.spines.right.set_visible(False)
            else:
                plt.yticks(*list(zip(*tick_positions.items())))

            # create slanted lines between the subplots
            d = .5  # proportion of vertical to horizontal extent of the slanted line
            kwargs = dict(marker=[(-d, -1), (d, 1)], markersize=12,
                          linestyle="none", color='k', mec='k', mew=1, clip_on=False)
            if i > 0:
                ax.plot([0, 0], [0, 1], transform=ax.transAxes, **kwargs)

            if i < len(xlims) - 1:
                ax.plot([1, 1], [0, 1], transform=ax.transAxes, **kwargs)

    # show the plot
    if not separate_plots:
        save_with_timestamp(figure_name)